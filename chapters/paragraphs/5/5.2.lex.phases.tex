% 5.2 Phases of translation [lex.phases]
\paragraph{} % 1
翻译语法规则的优先级由以下阶段规定。\footnote{实现表现的如同这些阶段会出现，尽管
实践中不同的阶段可以合并到一起。}

\begin{enumerate}[label={\arabic*}]
  \newcommand{\tpit}[1]{\item{\hspace{-0.5em}.#1\label{tpit\arabic{enumi}}}}
  \tpit % 1
    如果必要，物理源文件字符以实现定义的方式映射到基本源码字符集（为行结尾标记引
    入新行字符）。可接受的源文件字符集由实现定义。任何不在基本源码字符集
    （\ref{lex.charset}）中的源文件字符被替换成指代该字符的
    \nt{universal-character-name}。实现可能使用内部编码，只要源文件中所遇到的实
    际扩展字符和该源文件中表示为\nt{universal-character-name}（如使用
    \tm{\bs{}uXXXX}记法）的同一扩展字符被等价处理，除了原始字符串字面值中该替换
    被复原（\ref{lex.pptoken}）的地方。
  \tpit % 2
    删除反斜杠字符（\bs）后紧跟新行字符的每一个实例，连接物理源行形成逻辑源行。
    任何一个物理源行中只有最后一个反斜杠可以是这种连接的部分。除了原始字符串字面
    值中被复原的连接，如果连接产生匹配\nt{universal-character-name}语法的字符序
    列，则行为未定义。非空且不以新行字符结尾，或者在任何连接发生前以反斜杠紧跟新
    行结尾的源文件，应该如同有一个额外的新行字符被扩展到该文件中一样进行处理。
  \tpit % 3
    源文件被分解成预处理记号（\ref{lex.pptoken}）和空白字符序列（包括注释）。源
    文件不应该以部分预处理记号或部分注释\footnote{部分预处理记号可能来源于以多字
    符记号的起始部分作为结尾的源文件，该记号需要终止字符序列，比如缺少结尾\tm{"}
    或\tm{>}的\nt{header-name}。部分注释可能来源于以未收尾的\tm{/*}注释作为结尾
    的源文件。}结束。注释被替换成空白字符。保留新行字符。除新行以外的非空空白
    字符序列是否保留或替换成一个空白字符未指定。分割源文件字符成预处理标记的过程
    是上下文相关的。

    \begin{example}
      参见\tm{\#include}预处理指令中对\tm{<}的处理。
    \end{example}
  \tpit % 4
    执行预处理指令，展开宏调用并执行\tm{\_Pragma}一元运算符表达式。如果匹配
    \nt{universal-character-name}语法的字符序列由记号拼接产生
    （\ref{cpp.concat}），则行为未定义。一个\tm{\#include}预处理指令使得所命名的
    头或源文件从阶段\ref{tpit1}到阶段\ref{tpit4}递归的进行处理。所有预处理指令随
    后被删除。
  \tpit % 5
    字符或字符串字面值中的每一个源字符集成员，以及每一个转义序列和
    \nt{universal-character-name}或非原始字符串字面值被转换成对应执行字符集
    （\ref{lex.ccon}，\ref{lex.string}）成员；如果没有对应成员，则被转换成除空
    （宽）字符以外的实现定义成员。\footnote{实现不需要将所有非对应源字符转换成相
    同执行字符。}
  \tpit % 6
    连接相邻的字符串字面值。
  \tpit % 7
    分隔相邻标记的空白字符不再有意义。每一个预处理标记被转换成标记
    （\ref{lex.token}）。产生的标记作为翻译单元进行语法和语义分析。

    \begin{note} % note 1
      分析与翻译标记的过程可能偶尔会有一个标记被替换成其他标记序列的情况
      （\ref{temp.names}）。
    \end{note}

    \begin{note} % note 2
      源文件，翻译单元和翻译后的翻译单元不一定存成文件，这些实体与外部表示间也不
      一定存在一一对应关系。描述只是概念上的，且不指定某一特定实现。
    \end{note}
  \tpit % 8
    翻译后的翻译单元和实例化单元按如下组合起来：

    \begin{note} % note 3
      某些或全部来自库。
    \end{note}

    检查每个翻译单元以产生必要的实例化列表。

    \begin{note} % note 4
      可能包括显式要求的实例化（\ref{temp.explicit}）。
    \end{note}

    定位必要的模板定义。包含这些定义的翻译单元源码是否要求可见由实现定义。

    \begin{note} % note 5
      实现可能将足够的信息编码到翻译后的翻译单元中来确保此处不需要源码。
    \end{note}

    进行所有必要的实例化以产生\df{实例化单元}（\df{instantiation unit}）。

    \begin{note} % note 6
      类似于翻译后的翻译单元，但不含未实例化的模板引用和模板定义。
    \end{note}

    如任何实例化失败则程序为病态。
  \tpit % 9
    解析所有外部实体。链接所有库组件以满足当前翻译中未定义的实体引用。收集所有这
    样的翻译器输出组成程序镜像，该镜像包含在其执行环境中执行所需的信息。
\end{enumerate}
