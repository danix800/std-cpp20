% 6.9.2.3 Forward progress [intro.progress]
\paragraph{} % 1
实现可能假定任何线程最终会进行以下之一：
\begin{enumerate}
  \item 终止，
  \item 调用一个库I/O函数，
  \item 通过易失性\glvalue{}进行一个访问，或者
  \item 进行一个同步操作或原子操作。
\end{enumerate}
\begin{note}
  这旨在允许编译器变换，例如删除空循环，即使无法证明终止。
\end{note}

\paragraph{} % 2
定义为无锁（\ref{atomics.flag}）或指定为无锁（\ref{atomics.lockfree}）的原子函数
的执行为\df{无锁执行}。
\begin{enumerate}
  \item 如果仅有一个线程未在一个标准库函数中阻塞（\ref{defns.block})，该线程中的
        无锁执行应该完成。

        \begin{note}
          并发执行线程可能阻止无锁执行的进行。比如，该情形可以出现在加载锁定条件
          存储实现中。该属性有时称为无阻塞。
        \end{note}
  \item 当一个或多个无锁执行并发运行时，至少一个应该完成。

        \begin{note}
          某些实现提供该效果的绝对保证是困难的，因为来自其他线程的重复的，特别是
          不合时机的干扰可能阻止继续进行，比如，通过在加载锁定和条件存储指令间因
          不相关的目的而重复地偷取缓存线。对于遵循此推荐，并确定这种效果不会在期
          望的操作条件下无期限推迟进度的实现，这种反常可以被程序员安全地忽略掉。
          在本文件之外，该属性有时称作无锁。
        \end{note}
\end{enumerate}

\paragraph{} % 3
在线程执行期间，以下每一个都称为一个\df{执行步骤}：
\begin{enumerate}
  \item 线程执行的终止，
  \item 通过易失性\glvalue{}进行访问，或者
  \item 调用一个库I/O函数，一个同步操作或者一个原子操作的完成。
\end{enumerate}

\paragraph{} % 4
一个会阻塞（\ref{defns.block}）的标准库函数调用在等待阻塞条件满足过程中认为是继
续执行其执行步骤的。

\begin{example}
  一个阻塞直到I/O操作完成的库I/O函数可以认为在持续检查操作是否完成。每一个这样的
  检查包含一个或多个执行步骤，比如使用抽象机的可观察行为。
\end{example}

\paragraph{} % 5
\begin{note}
  由这一点以及关于最终必须执行哪一个执行线程的先前要求可得出结论，在没有执行步骤
  出现的情况下，没有执行线程可以永远执行。
\end{note}

\paragraph{} % 6
当执行步骤发生或无锁执行因为在标准库函数中还存在其他并发线程未被阻塞的情况而未完
成时，执行线程将取得进展。

\paragraph{} % 7
对于提供\df{并发向前进展保证}的执行线程，实现确保该线程将在不终止的情况下最终取
得进展。

\begin{note}
  不管其他执行线程（如果有）是否已经或正在取得进展，这都是必需的。 最终满足此要
  求意味着这将在未指明但有限的时间内发生。
\end{note}

\paragraph{} % 8
由实现所创建的执行\tm{main}（\ref{basic.start.main}）的执行线程以及由
\tm{std::thread}（\ref{thread.thread.class}）或\tm{std::jthread}
（\ref{thread.jthread.class}）所创建的执行线程是否提供并发向前进度保证由实现来定
义。通用目的的实现应提供这些保证。

\paragraph{} % 9
对一个提供\df{并行向前进展保证}的执行线程，如果其尚未执行任何执行步骤，则不要求
实现确保线程最终取得进展；一旦线程执行了一个执行步骤，则提供并发向前进度保证。

\paragraph{} % 10
\begin{note}
  这并未指定何时启动此执行线程的要求，通常由创建此执行线程的实体指定。例如，提供
  并发向前进展保证并以任意顺序依次执行一组任务中的任务的执行线程满足了这些任务的
  并行向前进展的要求。
\end{note}

\paragraph{} % 11
对于提供\df{弱并行向前进展保证}的执行线程，实现不保证该线程最终将取得进展。

\paragraph{} % 12
\begin{note}
  不管其他线程是否取得进展，都不能期望提供弱并行向前进展保证的执行线程取得进展；
  但是，可以使用如下定义的向前进展保证委托进行阻止以确保此类执行线程最终能够取得
  进展。
\end{note}

\paragraph{} % 13
并发向前进展保证要比并行前向进展保证要强，而并行向前进展保证比弱并行前向进展保证
要强。

\begin{note}
  例如，只有在各自执行线程提供并行向前进展保证的情况下，才可以保证执行线程之间的
  某些类型的同步取得进展，但不一定会在弱并行保证的情况下进行。
\end{note}

\paragraph{} % 14
当执行线程\nt{P}在一组执行线程\nt{S}完成后被指定为\df{以向前进展保证委托进行阻
塞}时，则在\nt{P}被阻塞在\nt{S}上的整个过程中，实现应确保\nt{S}中至少一个执行线
程提供的向前进展保证至少与\nt{P}的向前进展保证一样强。

\begin{note}
  未指明\nt{S}中选择哪个执行线程以及多少执行步骤。增强不是永久性的，并且在受影响
  执行线程整个生命周期的剩余时间内都不一定到位。只要\nt{P}被阻塞，实现就必须最终
  选择并潜在地增强\nt{S}中的一个执行线程。
\end{note}

一旦\nt{S}中的执行线程终止，便将其从\nt{S}中删除。一旦\nt{S}为空，则\nt{P}解除阻
塞。

\paragraph{} % 15
\begin{note}
  因此一个执行线程\nt{B}可以在一定时间内临时提供有效更强的向前进展保证，由于第二
  个执行线程\nt{A}被前向进度保证委托阻塞了。反过来，如果\nt{B}被\nt{C}的向前进展
  保证委托阻塞，这也可以暂时为\nt{C}提供更强的向前进展保证。
\end{note}

\paragraph{} % 16
\begin{note}
  如果\nt{S}中的所有执行线程完成执行（例如它们终止且没有错误地使用阻塞同步），那
  么\nt{P}向前进展保证委托操作的执行不会导致\nt{P}的进展保证被有效削弱 。
\end{note}

\paragraph{} % 17
\begin{note}
  这并没有消除关于为提供并行或弱并行的向前进展保证的执行线程阻塞同步的任何约束，
  因为不需要实现来增强其执行进度太弱而阻止总体进度的特定执行线程。
\end{note}

\paragraph{} % 18
实现应确保原子或同步操作所赋最终值（按修改顺序）将在有限的时间内对所有其他线程可
见。
