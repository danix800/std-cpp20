% 6.9.2.2 Data races [intro.races]
\paragraph{} % 1
根据以下规则，一个在特定点对线程\nt{T}可见的对象的值为该对象的初始化值，由\nt{T}
所赋给该对象的值，或者由另一个线程赋给该对象的值。

\begin{note}
  在某些情况下可能存在未定义行为。本子条款的大部分动机是希望通过明确和详细的可见
  性约束来支持原子操作。 但也隐式支持更受限程序上的一个更简单的视图。
\end{note}

\paragraph{} % 2
如果其中一个修改了一个内存位置（\ref{intro.memory}）而另一个读或修改相同内存位置
则两个表达式求值相\df{冲突}。

\paragraph{} % 3
标准库定义了一系列原子操作（第\ref{atomics}条）和\mtx{}操作（第\ref{thread}条）
，特别标识为同步操作。这些操作对在一个线程中对另一个线程中可见的赋值起到一个特殊
的作用。一个或多个内存位置上的同步操作是一个消耗操作，获取操作或释放操作，或者既
是获取也是释放操作。一个没有关联内存位置的同步操作是一个\fnc{}，可以是一个获取
\fnc{}，释放\fnc{}或者一个获取和释放\fnc{}。此外，存在放松的原子操作，它们不是同
步操作，以及原子\rmw{}操作，具有特殊的特性。

\begin{note}
  比如，一个获取\mtx{}的调用将在构成\mtx{}的位置进行获取操作。对应的，一个释放同
  一个\mtx{}的调用将在同一位置进行释放操作。非形式的说，在\nt{A}上进行一个释放操
  作强制其他位置上之前的副作用对在\nt{A}上执行消耗或获取操作的其他线程可见。“放
  松的”原子操作不是同步操作，即使与同步操作一样，它们也不会造成数据竞争。
\end{note}

\paragraph{} % 4
对一个特定原子对象\nt{M}的修改按某个特定的全序出现，称为\nt{M}的修改序。

\begin{note}
  对每一个原子对象，存在一个单独的顺序。不要求这些对所有对象可以组合成一个单个全
  序。一般地这是不可能的，因为不同线程可以观察到不一致顺序的不同对象修改。
\end{note}

\paragraph{} % 5
一个原子对象\nt{M}上的以释放操作\nt{A}为首的\df{释放序列}指\nt{M}的修改序中副作
用的一个最大连续子序列，其中第一个操作为\nt{A}，每一个后续操作是一个原子\rmw{}操
作。

\paragraph{} % 6
某些标准库调用与其他线程所进行的标准库操作\df{相同步}。比如，一个原子存-释放与
一个从存储中取值的原子取-获取相同步。

\begin{note}
  除所指定情形外，读一个后来的值不一定保证上述的可见性。这样的要求有时会干扰有效
  实现。
\end{note}

\begin{note}
  同步操作的规范定义了何时一个读另一个所写。对于原子对象，定义是清晰的。一个给定
  \mtx{}上的所有操作出现在单个全序中。每一个\mtx{}获取读取上一个\mtx{}释放所写的
  值。
\end{note}

\paragraph{} % 7
一个求值\nt{A}\df{依赖于}求值\nt{B}，如果
\begin{enumerate}
  \item \nt{A}的值用作\nt{B}的操作数，除非：
        \begin{enumerate}
          \item \nt{B}是\tm{std::kill\_dependency}（\ref{atomics.order}）的任何
                特例化的调用，或者
          \item \nt{A}是一个内置逻辑AND（\tm{\&\&}，见\ref{expr.log.and}）或逻辑
                OR（\tm{||}，见\ref{expr.cond}）运算符的左操作数，或者
          \item \nt{A}是条件（\tm{?:}，见\ref{expr.cond}）运算符的左操作数，或者
          \item \nt{A}是内置逗号（\tm{,}）运算符（\ref{expr.comma}）的左操作数；
        \end{enumerate}
        或者
  \item \nt{A}写入一个标量对象或位置\nt{M}，\nt{B}从\nt{M}中读取\nt{A}所写操作，
        并且\nt{A}前序于\nt{B}，或者
  \item 对某些求值\nt{X}，\nt{A}依赖于\nt{X}，\nt{X}依赖于\nt{B}。
\end{enumerate}

\begin{note}
  “依赖于”是“前序”的子集，并且类似地是严格线程内的。
\end{note}

\paragraph{} % 8
一个求值\nt{A}为\df{依赖前序于}求值\nt{B}，如果
\begin{enumerate}
  \item \nt{A}在一个原子对象\nt{M}是进行一个释放操作，在另一个线程中，\nt{B}在
        \nt{M}上进行一个消耗操作，并读取由\nt{A}所写的值，或者
  \item 对某些求值\nt{X}，\nt{A}依赖前序于\nt{X}，\nt{X}依赖前序于\nt{B}。
\end{enumerate}

\begin{note}
  关系“依赖前序于”类似于“同步于”，但使用释放/消耗代替释放/获取。
\end{note}

\paragraph{} % 9
一个求值\nt{A}\df{线程间先发生于}求值\nt{B}，如果
\begin{enumerate}
  \item \nt{A}同步于\nt{B}，或者
  \item \nt{A}依赖前序于\nt{B}，或者
  \item 对某些求值\nt{X}
        \begin{enumerate}
          \item \nt{A}同步于\nt{X}，且\nt{X}前序于\nt{B}，或者
          \item \nt{A}前序于\nt{X}，且\nt{X}线程间先发生于\nt{B}，或者
          \item \nt{A}线程间先发生于\nt{X}，且\nt{X}线程间先发生于\nt{B}。
        \end{enumerate}
\end{enumerate}

\begin{note}
  “线程间先发生于”关系描述的是“前序于”，“同步于”和“依赖前序于”关系的任意连接，存
  在两个例外。第一个例外是连接不允许以“依赖前序于”后跟“前序于”结束。该限制只适用
  于这种连接结尾的原因是任何后续的释放操作将为之前的消耗操作提供所需要的排序。第
  二个例外是连接不允许整个只包含“前序于”。该限制的原因是(1)允许“线程间先发生于”
  能够传递关闭（2）以下所定义的“先发生于”提供了整个只包含“前序于”关系。
\end{note}

\paragraph{} % 10
 求值\nt{A}\df{先发生于}求值\nt{B}（或者，等价的，\nt{B}\df{后发生于}\nt{A}，
 如果：
 \begin{enumerate}
  \item \nt{A}先发生于\nt{B}，或者
  \item \nt{A}线程间先发生于\nt{B}。
 \end{enumerate}
 实现应该确保没有程序执行在“先发生于”关系中演示出一个环。

\begin{note}
  该环只有通过消耗操作的使用才有可能。
\end{note}

\paragraph{} % 11
一个求值\nt{A}\df{简单先发生于}求值\nt{B}，如果要么
\begin{enumerate}
  \item \nt{A}前序于\nt{B}，或者
  \item \nt{A}同步于\nt{B}，或者
  \item \nt{A}简单先发生于\nt{X}，\nt{X}简单先发生于\nt{B}。
\end{enumerate}

\begin{note}
  在无消耗操作的情况下，先发生于和简单先发生于关系是等价的。
\end{note}

\paragraph{} % 12
求值\nt{A}\df{强先发生于}求值\nt{D}，如是要么
\begin{enumerate}
  \item \nt{A}前序于\nt{D}，或者
  \item \nt{A}同步于\nt{D}，且\nt{A}和\nt{D}都是序列一致的原子操作
        （\ref{atomics.order}），或者
  \item 存在求值\nt{B}和\nt{C}使得\nt{A}前序于\nt{B}，\nt{B}简单先发生于\nt{C}，
        \nt{C}简单先发生于\nt{D}或者
  \item 存在求值\nt{B}使得\nt{A}简单先发生于\nt{B}，\nt{B}简单先发生于\nt{D}。
\end{enumerate}

\begin{note}
  非正式的说，如果\nt{A}强先发生于\nt{B}，那么\nt{A}在所有上下文中都在\nt{B}之前
  先求值。强先发生于不排除消耗操作。
\end{note}

\paragraph{} % 13
一个标量对象或位域\nt{M}上的相对于\nt{M}上的一个值计算\nt{B}的\nt{可见副作用}满
足条件：
\begin{enumerate}
  \item \nt{A}先发生于\nt{B}，且
  \item 不存在\nt{M}的其他副作用\nt{X}使得\nt{A}先发生于\nt{X}，\nt{X}先发生于
        \nt{B}。
\end{enumerate}
一个非原子标量对象或位域\nt{M}的值，如求值\nt{B}所确定，应该是由\nt{A}的可见副作
用所存的值。

\begin{note}
  如果关于一个非原子对象或位域的哪个副作用可见存在歧义，则行为要么未指明要么未定
  义。
\end{note}

\begin{note}
  这说明了普通对象上的操作不是可见重排序的。没有数据竞争这实际上是无法检测到的，
  但必须确保以下定义的数据竞争以及对原子使用的适当限制，在简单的交错（顺序一致）
  执行中与数据竞争相对应。
\end{note}

\paragraph{} % 14
原子对象\nt{M}的值，如求值\nt{B}所确定，应该是修改\nt{M}的某些副作用\nt{A}所存的
值，其中\nt{B}不先发生于\nt{A}。

\begin{note}
  这种副作用的集合也受限于此处描述的剩余规则，且特别的受限于以下的一致性要求。
\end{note}

\paragraph{} % 15
如果修改原子对象\nt{M}的操作\nt{A}先发生于修改\nt{M}的操作\nt{B}，则\nt{A}在
\nt{M}的修改序中应该比\nt{B}早。

\begin{note}
  该要求称为写-写一致性。
\end{note}

\paragraph{} % 16
如果一个原子对象\nt{M}的一个值计算\nt{A}先发生于\nt{M}的一个值计算\nt{B}，且
\nt{A}取值自\nt{M}上的一个副作用\nt{X}，则由\nt{B}所计算的值应该是由\nt{X}所存的
值或者由\nt{M}上的副作用\nt{Y}所存的值，其中\nt{Y}跟在\nt{M}的修改顺序中\nt{x}之
后。

\begin{note}
  该要求称为读-读一致性。
\end{note}

\paragraph{} % 17
如果原子对象\nt{M}的一个值计算\nt{A}先发生于\nt{M}的一个操作\nt{B}，则\nt{A}应该
从\nt{M}上的副作用\nt{X}中取值，其中\nt{X}处于\nt{M}的修改序中\nt{B}之前。

\begin{note}
  该要求称为读-写一致性。
\end{note}

\paragraph{} % 18
如果一个原子对象\nt{M}的副作用\nt{X}先发生于\nt{M}的值计算\nt{B}之前，则求值
\nt{B}应该从\nt{X}中取值，或者从\nt{M}的修改序中跟在\nt{X}之后的副作用\nt{Y}中取
值。

\begin{note}
  该要求称为写-读一致性。
\end{note}

\paragraph{} % 19
\begin{note}
  以上四条一致性要求实际上禁止了编译器对单个对象的原子操作进行重新排序，即使操作
  均为放宽的加载。这实际上使得大部分硬件所提供的缓存一致性保证对\cpp{}原子操作可
  用。
\end{note}

\paragraph{} % 20
\begin{note}
  一个原子加载所观察到的值依赖于“先发生于”关系，而这依赖于原子加载所观察到的值。
  所预期理解是必须存在原子加载及其所观察到的修改间的关联，使得连同适当选择的修改
  顺序和按上述所衍生的“先发生于”关系，满足此处所要求的约束。
\end{note}

\paragraph{} % 21
两个行为是\df{潜在并发的}，如果
\begin{enumerate}
  \item 它们由不同线程进行，或者
  \item 它们是无序的，至少一个由信号处理程序进行，且不是都由同一个信号处理程序调
        用所进行。
\end{enumerate}
程序的执行包含\df{数据竞争}，如果它包含两个潜在并发的冲突行为，其中至少一个不是
原子操作，且均不是先发生于另一个，除了以下所述信号处理程序的特殊情形。任何这样的
数据竞争都导致未定义行为。

\begin{note}
  可以证明，正确使用\mtx{}和\tm{memory\_order::seq\_cst}操作来防止所有数据竞争且
  未使用其他同步操作的程序，其行为如同其构成线程所执行的操作是简单交织进行的，使
  得对象的每一个值计算取自该交织进行中该对象上的最后一个副作用。这通常称为“序列
  一致性”。但这只对无数据竞争程序有效，而无数据竞争程序不能观察到不改变单线程程
  序语义的大部分程序变换语义。事实上，大部分单线程程序变换仍是允许的，因为任何行
  为不同的程序都将具有未定义行为。
\end{note}

\paragraph{} % 22
类型\tm{volatile std::sig\_atomic\_t}的同一对象的两个访问，如果出现在同一线程中
则不会导致数据竞争，即使一个或多个出现在信号处理程序中。对每一个这样的信号处理程
序调用，调用信号处理程序的线程所进行的求值可以分为两组\nt{A}和\nt{B}，使得\nt{B}
中没有求值先发生于求值\nt{A}，且这样的\tm{volatile std::sig\_atomic\_t}对象的求
值如同\nt{A}中所有求值先发生于信号处理程序的执行，信号处理程序执行先发生于\nt{B}
中所有求值一样进行取值。

\paragraph{} % 23
\begin{note}
  引入赋值到一个不会被抽象机修改的潜在共享内存位置的编译器变换一般被本文件所排除
  在外，因为这样的赋值可能覆盖不同线程的另一个赋值，这种情况下抽象机的执行不会遇
  到数据竞争。这包括覆盖不同内存位置相邻成员的数据成员赋值的实现。可具有别名的原
  子的原子加载重排序也被排除在外了，因为这会违反一致性规则。
\end{note}

\paragraph{} % 24
\begin{note}
  引入对一个潜在共享内存位置的预测性读的变换，按本文件所定义，一般不会\cpp{}程序
  语义，因为它们潜在地引入了一个数据竞争。但在针对具有数据竞争语义\wellform{}定
  义的特定机器的优化编译器上下文中它们通常是有效的。对于不允许竞争或提供硬件竞争
  检测的假想机器它们是无效的。
\end{note}
