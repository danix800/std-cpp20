% 7.3.13 Pointer-to-member conversions [conv.mem]
\paragraph{} % 1
一个\nullp{}常量（\ref{conv.ptr}）可以转换为一个成员指针类型；结果为该类型的
\df{\Null{}成员指针值}，且不同于任何未由\nullp{}常量所创建的成员指针。这样的转换
称为\df{\Null{}成员指针转换}。同一类型的两个\Null{}成员指针值比较应该相等。
\Null{}成员指针常量到cv限定类型成员指针的转换是单个转换，而不是成员指针转换加上
一个限定转换（\ref{conv.qual}）。

\paragraph{} % 2
“\nt{cv} \tm{T}类型的\tm{B}的成员指针”类型的\prvalue{}，其中\tm{B}是一个类类型，
可以转换为一个“\nt{cv} \tm{T}类型的\tm{D}的成员指针”类型的\prvalue{}，其中\tm{D}
是一个派生（\ref{class.derived}）自\tm{B}的完整类类型。如果\tm{B}是\tm{D}的一个
不可访问（\ref{class.access}），有歧义（\ref{class.member.lookup}），或虚
（\ref{class.mi}）基类，或\tm{D}的虚基类的基类，则需要此转换的程序为\illform{}。
转换的结果引用的是与转换前成员指针所引用的相同的成员，但其引用的是基类成员如果是
一个派生类的成员。结果引用了D的B实例中的成员。因结果具有“\nt{cv} \tm{T}类型的
\tm{D}成员指针”类型，使用\tm{D}对象进行间接引用是合法的。结果与使用\tm{D}的
\tm{B}子对象通过指向\tm{B}的成员指针间接访问的结果相同。\Null{}成员指针值被转换
为目标类型的\Null{}成员指针值。\footnote{成员指针转换规则（从其中成员指针到派生
类成员指针）与对象指针转换（从派生类指针到基类指针）相反（\ref{conv.ptr}，
\ref{class.derived}）。该反转对确保类型安全是必须的。请注意成员指针不是一个对象
指针或成员指针，这类指针的转换规则对成员指针不适用。特别的，成员指针不能转换为
\tm{void*}。}
